# Python Scripting Skill

## When to Use
Use this skill when creating Python scripts for automation, data processing, API integrations, or any standalone utility scripts.

## File Structure

```python
#!/usr/bin/env python3
"""
One-line description of what this script does.

Usage:
    python script_name.py [options]
"""

# Imports: stdlib → third-party → local
import logging
import os
from pathlib import Path

import requests  # third-party

# Constants
API_BASE_URL = os.getenv("API_BASE_URL", "https://api.example.com")
OUTPUT_DIR = Path("output")

# Logging setup
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


def main():
    """Entry point."""
    pass


if __name__ == "__main__":
    main()
```

## Rules

### Always Do
- Use `python3` explicitly (not `python`)
- Type hints on all functions
- Docstrings on public functions
- `logging` module (never `print` for status/errors)
- `pathlib.Path` for file operations (not `os.path`)
- Environment variables for secrets and config
- Virtual environments (`python3 -m venv venv`)

### Never Do
- Global mutable state
- Bare `except:` clauses
- `print()` for logging or debugging
- Hardcoded secrets or API keys
- `os.path` when `pathlib` works
- Install packages globally

## Type Hints

```python
def fetch_data(url: str, timeout: int = 30) -> dict:
    """Fetch JSON from URL."""
    ...

def process_items(items: list[dict]) -> list[str]:
    """Extract names from items."""
    ...

def save_output(data: dict, path: Path) -> None:
    """Save data to JSON file."""
    ...
```

For complex types:
```python
from typing import Optional

def find_user(user_id: str) -> Optional[dict]:
    """Return user or None if not found."""
    ...
```

## Error Handling

```python
# Specific exceptions, not bare except
try:
    response = requests.get(url, timeout=30)
    response.raise_for_status()
except requests.Timeout:
    logger.error(f"Timeout fetching {url}")
    raise
except requests.HTTPError as e:
    logger.error(f"HTTP error {e.response.status_code}: {url}")
    raise

# Custom exceptions for business logic
class ValidationError(Exception):
    """Raised when input validation fails."""
    pass
```

## Logging

```python
# Setup once at module level
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# Use throughout
logger.info(f"Processing {len(items)} items")
logger.warning(f"Skipping invalid record: {record_id}")
logger.error(f"Failed to connect: {e}")

# For debugging (set level to DEBUG when needed)
logger.debug(f"Raw response: {response.text}")
```

## File Operations

```python
from pathlib import Path

# Paths
output_dir = Path("output")
output_dir.mkdir(exist_ok=True)

file_path = output_dir / "results.json"

# Reading
content = file_path.read_text(encoding="utf-8")
data = json.loads(content)

# Writing
file_path.write_text(json.dumps(data, indent=2), encoding="utf-8")

# Checking
if file_path.exists():
    ...

# Listing
for csv_file in output_dir.glob("*.csv"):
    ...
```

## HTTP Requests

```python
import requests

def fetch_json(url: str) -> dict:
    """Fetch JSON with proper error handling."""
    try:
        response = requests.get(
            url,
            timeout=30,
            headers={"User-Agent": "MyScript/1.0"}
        )
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        logger.error(f"Request failed: {e}")
        raise
```

## Configuration

```python
import os

# Required config (fail fast if missing)
API_KEY = os.environ["API_KEY"]  # Raises KeyError if not set

# Optional config with defaults
DEBUG = os.getenv("DEBUG", "false").lower() == "true"
TIMEOUT = int(os.getenv("TIMEOUT", "30"))
OUTPUT_DIR = Path(os.getenv("OUTPUT_DIR", "output"))
```

Document in `.env.example`:
```
API_KEY=your-api-key-here
DEBUG=false
TIMEOUT=30
OUTPUT_DIR=output
```

## CLI Arguments (when needed)

```python
import argparse

def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Process data files")
    parser.add_argument("input", type=Path, help="Input file path")
    parser.add_argument("-o", "--output", type=Path, default=Path("output.csv"))
    parser.add_argument("-v", "--verbose", action="store_true")
    return parser.parse_args()

def main():
    args = parse_args()
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    ...
```

## Virtual Environments

```bash
# Create
python3 -m venv venv

# Activate (macOS/Linux)
source venv/bin/activate

# Activate (Windows)
venv\Scripts\activate

# Install dependencies
pip3 install -r requirements.txt

# Freeze current packages
pip3 freeze > requirements.txt
```

Always add to `.gitignore`:
```
venv/
__pycache__/
*.pyc
.env
```

## Script Template

```python
#!/usr/bin/env python3
"""
Brief description of what this script does.

Usage:
    python3 script_name.py
    
Environment Variables:
    API_KEY: Required. Your API key.
    DEBUG: Optional. Set to 'true' for verbose logging.
"""

import logging
import os
from pathlib import Path

# Third-party imports here

# Configuration
API_KEY = os.environ["API_KEY"]
DEBUG = os.getenv("DEBUG", "false").lower() == "true"
OUTPUT_DIR = Path("output")

# Logging
logging.basicConfig(
    level=logging.DEBUG if DEBUG else logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


def main() -> None:
    """Entry point."""
    logger.info("Starting script")
    
    OUTPUT_DIR.mkdir(exist_ok=True)
    
    # Your logic here
    
    logger.info("Done")


if __name__ == "__main__":
    main()
```

## Checklist Before Commit

- [ ] Type hints on all functions
- [ ] Docstring on module and public functions
- [ ] No `print()` statements (use logger)
- [ ] No hardcoded secrets
- [ ] Error handling with specific exceptions
- [ ] `requirements.txt` updated if deps changed
- [ ] `.env.example` documents required env vars
- [ ] Script runs without errors